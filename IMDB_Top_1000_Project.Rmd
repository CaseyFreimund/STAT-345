---
title: "Top 1000 Movies According to IMDB Users"
author: "Casey Freimund"
output: html_document
---

```{r warning=FALSE,results='hide'}
library(knitr)
library(ggplot2)
library(fitdistrplus)
```

## Finding The Data
```{r}
#DATA LOADER
#A function that takes in an empty vector and reads in the html files that contain data on the top 1000 movies on IMDB. It then combines them into one character vector and outputs that vector, 'movies'
#v = empty vector
html_loader=function(v){
  imdb50=readLines("imdb50.html")
  imdb100=readLines("imdb100.html")
  imdb150=readLines("imdb150.html")
  imdb200=readLines("imdb200.html")
  imdb250=readLines("imdb250.html")
  imdb300=readLines("imdb300.html")
  imdb350=readLines("imdb350.html")
  imdb400=readLines("imdb400.html")
  imdb450=readLines("imdb450.html")
  imdb500=readLines("imdb500.html")
  imdb550=readLines("imdb550.html")
  imdb600=readLines("imdb600.html")
  imdb650=readLines("imdb650.html")
  imdb700=readLines("imdb700.html")
  imdb750=readLines("imdb750.html")
  imdb800=readLines("imdb800.html")
  imdb850=readLines("imdb850.html")
  imdb900=readLines("imdb900.html")
  imdb950=readLines("imdb950.html")
  imdb1000=readLines("imdb1000.html")
  
  movies=c(imdb50,imdb100,imdb150,imdb200,imdb250,imdb300,imdb350,imdb400,imdb450,imdb500,imdb550,imdb600,imdb650,imdb700,imdb750,imdb800,imdb850,imdb900,imdb950,imdb1000)
  
  return(movies)
}
```

```{r}
#TITLE FINDER
#A Function that takes in a character string and searches for a pattern that contains the movie title. It then 'gets rid' of any unnecessary symbols and/or punctuations that don't pertain to the movie and outputs a vector that contains the movie titles, 'titles'.
#char.v = character string
title.finder=function(char.v){
  
  title.pattern=">\\s+<img\\s+alt.*"
  start.pat="([0-9]|[A-Z])"
  stop.pat="\"$"

  title.junk=regmatches(char.v,regexpr(title.pattern,char.v))
  titles=substr(title.junk,start = regexpr(start.pat,title.junk),stop = regexpr(stop.pat,title.junk)-1)
  titles=titles[titles!=""]
  return(titles)
}
```

```{r}
#GENRE FINDER
#A funtion that takes in a character string and searches for a pattern that contains the movies' genre(s). It then 'gets rid' of any unnecessary symbols and/or punctuations that don't pertain to the movie genre(s) and outputs a vector that contains the movie genres, 'genre'.
#char.v = character string
genre.finder=function(char.v){
  
  genre.pattern="[A-Z].*\\s+</span>"
  start.pat="[A-Z]"
  stop.pat="[a-z]\\s+</span>"
  
  genre.junk=regmatches(char.v,regexpr(genre.pattern,char.v))
  genre=substr(genre.junk,start = regexpr(start.pat,genre.junk),stop = regexpr(stop.pat,genre.junk))
  
  return(genre)
}
```

```{r}
#ACTOR FINDER
#A funtion that takes in a character string and searches for the location of the top 4 actors/actresses. It then 'gets rid' of any unnecessary symbols and/or punctuations that don't pertain to their names and outputs a vector that contains the top 4 paid actors and actresses from each movie, 'actor'.
#char.v = character string
actor.finder=function(char.v){
  
  actors.pattern="Stars:"
  stars.loc=grep(actors.pattern,char.v)
  
  a1.loc=stars.loc+2
  a2.loc=stars.loc+4
  a3.loc=stars.loc+6
  a4.loc=stars.loc+8

  a1=char.v[a1.loc]
  a2=char.v[a2.loc]
  a3=char.v[a3.loc]
  a4=char.v[a4.loc]

  stop.pat="</a>"

  a1=substr(a1,start = 2,stop = regexpr(stop.pat,a1)-1)
  a2=substr(a2,start = 2,stop = regexpr(stop.pat,a2)-1)
  a3=substr(a3,start = 2,stop = regexpr(stop.pat,a3)-1)
  a4=substr(a4,start = 2,stop = regexpr(stop.pat,a4)-1)
  
  actor=paste(a1,a2,a3,a4,sep = ", ")
  
  return(actor)
}
```

```{r}
#REVENUE FINDER
#A funtion that takes in a character string and searches for the location of the gross US revenue of a movie. It then 'gets rid' of any unnecessary symbols and/or punctuations that don't pertain to the gross US revenue and outputs a vector that contains the the gross US revenue for each movie, 'rev'. If gross US revenue isn't listed, gross revenue becomes NA.
#char.v = character string
rev.finder=function(char.v){
  
  rev.pat="Votes:"
  rev.loc=grep(rev.pat,char.v)
  rev.loc=rev.loc+3
  rev=char.v[rev.loc]
  rev=substr(rev,start = regexpr("\\$[0-9]",rev)+1,stop = regexpr("M",rev)-1)
  rev=as.numeric(rev)
  return(rev)
}
```

```{r}
#RELEASE DATE FINDER
#A funtion that takes in a character string and searches for the location of the year when the movie was released. It then gets rid of any unnecessary symbols and/or punctuations and outputs a vector that contains the year in which the movie was released, 'date'.
#char.v = character string
year.finder=function(char.v){
  
  date.pat="lister-item-year.*[0-9]{4}"
  date.junk=regmatches(char.v,regexpr(date.pat,char.v))
  date=substr(date.junk,start = regexpr("[0-9]",date.junk),stop = length(date.junk))
  date=as.numeric(date)
  
  return(date)
}
```

```{r}
#RATING/VOTES FINDER
#A funtion that takes in a character string and searches for the location of the rating/voting statistics. It then isolates the average rating into 1 variable, 'rates', and the total number of votes, 'votes', into another variable. Then it gets rid of any unnecessary symbols and/or punctuations and outputs a list of 2 vectors that contain the average rating by IMDB users `$rating` and the total number of votes `$votes`.
#char.v = character string
vote.finder=function(char.v){
  
  vote.pat="Users rated.*votes"
  vote.junk=regmatches(char.v,regexpr(vote.pat,char.v))
  
  rate=substr(vote.junk,start = regexpr("[0-9]",vote.junk),stop = regexpr("[0-9]/[0-9]{2}",vote.junk))
  rate=as.numeric(rate)
  
  votes=substr(vote.junk,start = regexpr("\\([0-9]",vote.junk)+1,stop = regexpr("\\svotes",vote.junk))
  votes=gsub("(\\,)+","",votes)
  votes=as.numeric(votes)  
  
 return(list(rating=rate,votes=votes)) 
}
```

```{r}
#INFO FINDER
#A function that takes in a character string and searches for the rating, total votes, title, year released, genre, top 4 paid actors, and gross US revenue for a list of movies and outputs a chart of the previously stated categories.
#v = character string
info.finder=function(v){
  
  Rating=vote.finder(v)$rating
  Total_Votes=vote.finder(v)$votes
  Title=title.finder(v)
  Year=year.finder(v)
  Genre=genre.finder(v)
  Actors=actor.finder(v)
  Revenue=rev.finder(v)
  
  movie.chart=cbind.data.frame(Rating,Total_Votes,Title,Year,Genre,Actors,Revenue)
  
  movie.chart$Title=as.character(movie.chart$Title)
  movie.chart$Genre=as.character(movie.chart$Genre)
  movie.chart$Actors=as.character(movie.chart$Actors)
  
  return(movie.chart)
}
```

```{r}
#Reads in the movie text for the top 1000 movies and puts the relevant information into a dataframe called 'movies'
movie.text=0
movie.text=html_loader(movie.text)
movies=info.finder(movie.text)
```

```{r}
#Checks that data aligns properly by printing the first 5 and last 5 movies
kable(movies[1:5,],caption = "Movies #1-5")
kable(movies[996:1000,],caption = "Movies #996-1000")
```

## Probability Distributions for Numerical Data
```{r warning=FALSE,message=FALSE,echo=FALSE}
par(mfrow=c(4,1))

#Average user rating density plot
rate.mu=summary(movies$Rating)[[4]]
ggplot(data = movies,aes(x=Rating))+geom_density(fill="gold",alpha=0.5)+xlim(7,10)+labs(title = "Top 1000 Movie Ratings by IMDB Users",x = "Average User Rating (1-10)",y = "Density")+geom_vline(xintercept = rate.mu,linetype="dashed",color="black")+scale_x_continuous(breaks = seq(7, 10, by = 0.25))


#Total Votes Density Plot
votes.mu=summary(movies$Total_Votes)[[4]]
ggplot(data = movies,aes(x=Total_Votes))+geom_density(aes(y=..scaled..),fill="gold",alpha=0.5)+labs(title = "Number of Ratings for Top 1000 Movies on IMDB",x="Number of Ratings per Movie",y="Density",subtitle = "Votes range from 25,078-2,061,970")+geom_vline(xintercept = votes.mu,linetype="dashed",color="black")+scale_x_continuous(breaks = seq(25000, 21000000, by = 250000))


#Release Date Density Plot
year.mu=summary(movies$Year)[[4]]
ggplot(data=movies,aes(x=Year))+geom_density(aes(y=..scaled..),fill=rgb(65,105,225,maxColorValue=225),alpha=0.5)+xlim(min(movies$Year),max(movies$Year))+labs(title="Top 1000 Movies' Release Date",x="Year Released",y="Density",subtitle = "1920-2019")+scale_x_continuous(breaks = seq(1920, 2019, by = 10))


#Revenue Density Plot
rev.mu=summary(movies$Revenue)[[4]]
rev.plot=ggplot(data = movies,aes(x=Revenue))+geom_density(aes(y=..scaled..),fill=rgb(46,139,87,maxColorValue=139),alpha=0.5)+geom_vline(xintercept = rev.mu,linetype="dashed",color="black")+labs(title = "Gross US Revenue of Top 1000 Movies",y="Density",x="Revenue (in Millions of $)",subtitle = "Movies at $0 made less than $10,000 in US Revenue")+scale_x_continuous(breaks = seq(0, 940, by = 100))
rev.plot
```

## Distribution Fitting to Numerical Data

#### Revenue

When fitting the exponential and log-normal distribution to the revenue data, I opted to omit the movies that didn't have a gross US revenue reported. If I were to insert values in place of the NA values, it would have skewed my distributions with parameters that truly didn't reflect the data set.  When I was fitting the log-normal distribution to the revenue data, I had to omit values that were equal to 0, because log(0) is undefined and if I were to input a small decimal equal to about 0, 0.000001 for example, the log of my small decimal value would result in large negative numbers and potentially skew my parameter estimates.

##### -Exponential Distribution
```{r warning=FALSE, message=FALSE,echo=FALSE,results='hide'}
#Fits exponential distribution to revenue data and checks the fit.
revs.noNA=as.vector(na.omit(movies$Revenue))
revs.gr8r.0=which(revs.noNA>0)

#Function that takes in a vector of numbers 'dat' and finds the lambda estimate for an exponential dist. Returns 'lambda'. 
expo.est=function(dat){
  lambda=1/mean(dat)
  return(lambda)
}
#Tests that the exponential parameter function works properly
test.exp = rexp(1000,rate = 25)
expo.est(test.exp)
```

```{r warning=FALSE,message=FALSE,echo=FALSE}
rev.lambda=expo.est(revs.noNA)

plot(density(revs.noNA),main = "Gross US Revenue of top 1000 Movies",xlab = "Revenue (in Millions of $)")
curve(dexp(x,rate=rev.lambda),add=TRUE,col="red")
legend(x=c("topright"),legend=c("Actual Revenues","Exponential Dist. Estimates"),col = c("Black","Red"),lty = 1)

qqplot(qexp(ppoints(length(movies$Revenue))),movies$Revenue,col="red",xlab = "Theoretical Quantiles",ylab = "Sample Quantiles",main="Q-Q Plot for Exponential Distribution and Revenue");qqline(movies$Revenue)

ks.test(movies$Revenue,pexp,rev.lambda)
```

##### -Log-Normal Distribution

```{r warning=FALSE, message=FALSE,echo=FALSE,results='hide'}
#Fits log-normal distribution to revenue data and checks the fit
#Function that takes in a vector of numbers 'dat' and finds the estimates for mu-hat and sigma-hat^2 for the log-normal distribution. Outputs a list 'est' that contains 'mu.hat' and 'sig.hat'.
log.norm.est = function(dat) {
  mu.hat = (sum(log(dat))) / length(dat)
  sigma.hat = sum((log(dat) - mu.hat) ^ 2) / length(dat)
  est = list(mu.hat = mu.hat, sigma.hat = sigma.hat)
  return(est)
}
#tests that the log-normal parameter function works properly
test.log = rlnorm(1000,meanlog = 5, sdlog = 2.5)
log.norm.est(test.log)
```

```{r warning=FALSE,message=FALSE,echo=FALSE}
log.mu=log.norm.est(revs.gr8r.0)[[1]]
log.sig=sqrt(log.norm.est(revs.gr8r.0)[[2]])

plot(density(revs.noNA),main = "Gross US Revenue of top 1000 Movies",xlab = "Revenue (in Millions of $)")
curve(dlnorm(x,log.mu,log.sig),add = TRUE,col="RED")
legend(x=c("topright"),legend=c("Actual Revenues","Log-Normal Dist. Estimates"),col = c("Black","Red"),lty = 1)

qqplot(qlnorm(ppoints(length(movies$Revenue))),movies$Revenue,col="red",xlab = "Theoretical Quantiles",ylab = "Sample Quantiles",main="Q-Q Plot for Log-Normal Distribution and Revenue");qqline(movies$Revenue)

ks.test(revs.gr8r.0,plnorm,log.mu,log.sig)
```

Distribution Fitted to Revenue|Parameters|Estimated Values
-----|-----|-----|
Exponential|$\lambda$|0.01474
   |   |   |
Log-Normal|$\hat{\mu}$|5.74328
|     |$\hat{\sigma}^2$|0.96797

After fitting an exponential distribution and log-normal distribution to the revenue data, I ran a few tests to determine their good-ness of fit relative to the data. By creating a density plot of the revenue data and overlaying both distributions, I was able to see what distributions appeared to 'fit' the data. Through this test, it appeared that the exponential distribution best fit the revenue data, but to be sure I conducted two more tests. My next test was to create a Q-Q Plot for both distributions. For the exponential distribution, the plotted points fall closely around the identity line, but don't fall on the line enough for us to say the exponential distribution fits our revenue data, especially as our Revenue increases. When looking at the Q-Q Plot for the log-normal distribution, we don't have any points falling on our identity line, making the log-normal distribution a poor fit for the revenue data. My final test for the exponential and log-normal distributions was a Kolmogorov-Smirnov Test. Both tests resulted in p-values close to 0, therefore making both distributions 'appear' to fit better than the actually do. Finally, from these three tests, I've concluded that our exponential distribution best fits our revenue data.


#### Average User Rating

##### -Gaussian (Normal) Distribution

```{r warning=FALSE, message=FALSE,echo=FALSE,results='hide'}
#Fits Gaussian distribution to avg. user rating and checks the fit
#Function that takes in a vector of numbers 'dat' and finds the estimates for mu-hat and sigma-hat^2 for the normal distribution. Outputs a list 'est' that contains 'mu.hat' and 'sig.hat'.
norm.est = function(dat) {
  mu.hat = mean(dat)
  sigma.hat = var(dat)
  est = list(mu.hat = mu.hat, sigma.hat = sigma.hat)
  return(est)
}
#tests that the normal parameter function works properly
test.norm = rnorm(1000,mean = 75, sd = 5)
norm.est(test.norm)
```

```{r warning=FALSE,message=FALSE,echo=FALSE}
norm.mu=norm.est(movies$Rating)[[1]]
norm.sig=sqrt(norm.est(movies$Rating)[[2]])

plot(density(movies$Rating),main = "Top 1000 Movie Ratings by IMDB Users",xlab = "Average User Rating (1-10)")
curve(dnorm(x,mean = norm.mu,sd=norm.sig),add = TRUE,col="RED")
legend(x=c("topright"),legend=c("Actual Rating","Normal Dist. Estimates"),col = c("Black","Red"),lty = 1)

qqplot(qnorm(ppoints(length(movies$Rating))),movies$Rating,col="red",xlab = "Theoretical Quantiles",ylab = "Sample Quantiles",main="Q-Q Plot for Normal Distribution and Avg. Rating");qqline(movies$Rating)

ks.test(movies$Rating,pnorm,norm.mu,norm.sig)
```

##### -Gamma Distribution

```{r warning=FALSE, message=FALSE,echo=FALSE,results='hide'}
#Fits Gamma distribution to avg. user rating and checks the fit
#Function that takes in a vector of numbers 'dat' and finds the estimates for the shape and scale for the gamma distribution. Outputs a list 'est' that contains 'shape' and 'scale'.
gam.est = function(dat) {
  dat.mean = mean(dat)
  dat.var=var(dat)
  alpha.hat=(dat.mean^2)/dat.var
  beta.hat=dat.var/dat.mean
  est=list(shape=alpha.hat,scale=beta.hat)
  return(est)
}
#tests that the gamma parameter function works properly
test.gamma = rgamma(1000, shape=0.5, scale=25)
gam.est(test.gamma)

```

```{r warning=FALSE,message=FALSE,echo=FALSE}
shape=gam.est(movies$Rating)[[1]]
scale=gam.est(movies$Rating)[[2]]

plot(density(movies$Rating),main = "Top 1000 Movie Ratings by IMDB Users",xlab = "Average User Rating (1-10)")
curve(dgamma(x,shape = shape,scale = scale),add = TRUE,col="RED")
legend(x=c("topright"),legend=c("Actual Rating","Gamma Dist. Estimates"),col = c("Black","Red"),lty = 1)

qqplot(qgamma(ppoints(length(movies$Rating)),shape = 1),movies$Rating,col="red",xlab = "Theoretical Quantiles",ylab = "Sample Quantiles",main="Q-Q Plot for Gamma Distribution and Avg. Rating");qqline(movies$Rating)

ks.test(movies$Rating,pgamma,shape,scale)
```

Distribution Fitted to Average User Rating|Parameters|Estimated Values
-----|-----|-----|
Gaussian|$\hat{\mu}$|7.9457
|     |$\hat{\sigma}^2$|0.0787
   |   |   |
Gamma|$a$(shape)|802.2107
|     |$s$(scale)|0.0099

When I fit a normal and gamma distribution to the average user rating data, I found that there wasn't significant evidence that either distribution fit better than the other or that either distribution fit the data well.  When I overlayed my distributions with the average user rating density plot, I found that both distributions had a similar shape, relative to eachother, and that they both 'fit' the sample data in an 'ok' way. Comparing their Q-Q Plots, neither distributions had plotted points that fell mostly on the identity line and both showed signs of skewness. After running a KS test, both tests yield a p-value close to 0, making both distributions 'appear' to be a good fit. Based on these three tests, I've concluded that there wasn't enough evidence to prove that either distribution is a good fit for the average user rating data.


#### Number of Votes

##### -Geometric Distribution

```{r warning=FALSE, message=FALSE,echo=FALSE,results='hide'}
#Fits geometric distribution to Number of Votes and checks the fit
#Function that takes in a vector of numbers 'dat' and finds the estimate for p-hat for the geometric dist. Outputs a single value, 'p.hat'.
geo.est = function(dat) {
  p.hat=mean(dat)^-1
  return(p.hat)
}
#tests that the geometric parameter function works properly
test.geo = rgeom(1000, prob = 1/4)
geo.est(test.geo)
```

```{r warning=FALSE,message=FALSE,echo=FALSE}
p.hat=geo.est(movies$Total_Votes)

plot(density(movies$Total_Votes),main = "Number of Ratings for Top 1000 Movies on IMDB",xlab = "Number of Ratings per Movie")
curve(dgeom(x,p.hat),add = TRUE,col="RED")
legend(x=c("topright"),legend=c("Actual Rating","Geometric Dist. Estimates"),col = c("Black","Red"),lty = 1)

qqplot(qgeom(ppoints(length(movies$Total_Votes)),0.5),movies$Total_Votes,col="red",xlab = "Theoretical Quantiles",ylab = "Sample Quantiles",main="Q-Q Plot for Geometric Distribution and Total Rates");qqline(movies$Total_Votes)

ks.test(movies$Total_Votes,pgeom,p.hat)
```

##### -Poisson Distribution

```{r warning=FALSE, message=FALSE,echo=FALSE,results='hide'}
#Fits poisson distribution to Number of Votes and checks the fit
#Function that takes in a vector of numbers 'dat' and finds the estimate for lambda for the poisson dist. Outputs a single value, 'lambda'.
poi.est=function(dat){
  lambda=mean(dat)
  return(lambda)
}
#tests that the poisson parameter function works properly
test.poi = rpois(1000,lambda = 34)
poi.est(test.poi)
```

```{r warning=FALSE, message=FALSE,echo=FALSE}
votes.lambda=poi.est(movies$Total_Votes)

plot(density(movies$Total_Votes),main = "Number of Ratings for Top 1000 Movies on IMDB",xlab = "Number of Ratings per Movie")
curve(dpois(x,lambda = votes.lambda),add = TRUE,col="RED")
legend(x=c("topright"),legend=c("Actual Rating","Poisson Dist. Estimates"),col = c("Black","Red"),lty = 1)

qqplot(qpois(ppoints(length(movies$Total_Votes)),1),movies$Total_Votes,col="red",xlab = "Theoretical Quantiles",ylab = "Sample Quantiles",main="Q-Q Plot for Poisson Distribution and Total Rates");qqline(movies$Total_Votes)
```

Distribution Fitted to Total Ratings per Movie|Parameters|Estimated Values
-----|-----|-----|
Geometric|$p$|4.06095e-06
   |   |   |
Poisson|$\lambda$|246247.424

Finally, I fit a geometric and poisson distribution to the total number of votes per movie data set.  While testing the geometric distribution with a Q-Q Plot, it appeared that the geometric distribution was not a good fit, as seen above.  I also found that when I plotted the number of ratings density plot over my estimated geometric distribution, they were lacking in similar shape. Therefore it did not seem plausible to conclude that the geometric distribution was a good fit for this data set.  Meanwhile, the KS test said otherwise, but due to the shape of both density plots side by side I concluded that the the geometric distribution did not fit 'well' for this data set. In my attempt to fit a poisson distribution to the total number of votes data, I plotted the density of my distribution with the actual data, and found that my distribution resulted in a line that did not resemble the actual density plot at all.  Then by making a Q-Q Plot of the data I was also able to confirm that the poisson distribution was also not a good fit for the total number of ratings data.

#### Good Acting or Good Movie Genre?

Under the "Stars" heading for each movie, IMDB lists the top 4 highest billed actors for each movie. Shown in the table below is a list of the top 5 actors who are one of the highest billed actors of a movie, in more than 5 of IMDB's 'Top 1000 Movies' list. The final column in the table, `Top2Genres`, consists of the two genres that the actor would most likely appear in, if that movie made this top 1000 list. For example, of the 16 'Top 1000 Movies' that Robert De Niro has starred in, if we were to draw one of them at random, they would most likely be listed as either a Drama and/or Crime movie.  

```{r warning=FALSE, message=FALSE,echo=FALSE}
#Finds Actors who have appeared in more than 5 of IMDB's top 1000 Movies and puts them into a data frame
actors=movies$Actors
actors=unlist(strsplit(actors,split = ", "))
actor.table=sort(table(actors),decreasing = TRUE)
top.actor=data.frame(actor.table[actor.table>=5])
top.actor$actors=as.character(top.actor$actors)

#Adds a column to the `top.actor` data frame and finds each actors 2 most frequent movie genres they act in.
top.actor$genre = NA
for (i in 1:nrow(top.actor)) {
  loc.name = grep(top.actor[i, 1], movies$Actors)
  movie.info = movies[loc.name, ]
  actor.genre = movie.info$Genre
  actor.genre = unlist(strsplit(actor.genre, split = ", "))
  top.genres = sort(table(actor.genre), decreasing = TRUE)
  top.genres = data.frame(top.genres)
  top2.genres = top.genres[1, 1]
  top2.genres = paste(top2.genres, top.genres[2, 1], sep = ", ")
  top.actor[i, 3] = top2.genres
}
names(top.actor)=c("Actors","NumberOfMovies","Top2Genres")
```

```{r}
kable(top.actor[1:5,])
```

But, how does an actor appear as one of the highest billed actors in multiple movies from the 'Top 1000 Movies' list? Could it have something to do with their acting ability, or could it be the type of movie they chose to act in, that makes this movie a success. I decided to explore this hypothesis with the same data set. I started off by locating every actor who appeared in five or more movies on IMDB's 'Top 1000 Movies' list. I then took all 86 'top actors' and found the genre(s) of the movies they appeared in. Shown below is a pie chart of the top movie genres that an actor would appear in, if they were to appear in more than 5 movies on this list.  

```{r warning=FALSE, message=FALSE,echo=FALSE}
g1 = top.actor$Top2Genres
g1 = unlist(strsplit(g1, split = ", "))
g.frame = data.frame(sort(table(g1), decreasing = TRUE)[1:10])

pct = round(g.frame$Freq/sum(g.frame$Freq)*100)
pct=as.character(pct);pct=paste(pct,"%",sep = "")

pie(x=g.frame$Freq,labels = pct,col = rainbow(length(pct)),main = "Top movie genres for actors who appear in more than 5 films")
legend(x=c("right"),legend=g.frame$g1,col = rainbow(length(pct)),pch=20)
```

From this, I was able to find that the majority of these 'top actors,' have acted in a Drama movie. What I found to be most significant about this pie chart was the second most frequent movie genre, that these 86 'top actors' may act in, was an Adventure movie. However, it's more than three times smaller than the percentage of actors who have acted in Drama Movies. Raising the question, are these considered the 'top actors' due to they're great at acting ability, or because they seem to land roles in a popular movie genre.